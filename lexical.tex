\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}

\usepackage{verbatim}
\usepackage{xspace}
\newcommand{\code}[1] {\texttt{\footnotesize{#1}}}

\title {
    Dynamic Allocation with Lexical Memory Management
    % under Structured Programming
}

\author{Anonymous}
\address{Anonymous}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

%\begin{resumo} 
%\end{resumo}

\section{Introduction}

The classical structured programming paradigm determines the control flow of
programs based on the lexical hierarchical structure of the source code.
%
In principle, programmers rely on the textual nesting of sequences,
conditionals, loops, and subroutines to break the source code into blocks to
better organize and reason about the program.~\cite{TODO}
%
Lexical blocks also determine the scope of variables, limiting their visibility
and lifetime, which helps to reason, not only about control flow, but also
about the memory organization of programs.

Regarding memory management, structured programming typically provides global
and local variables that use the static and stack memory regions to hold
fixed-size data types, and also provides references to dynamically-allocated
objects that use the heap to hold variable-size data types.
%
The static and stack regions provide automatic memory management that are easy
to reason, since they deallocate memory in blocks that respect the lexical
structure of the program.
%
However, the life cycle of objects that live in the heap have no correspondence
with the program structure, which diverges from the basic principle of
structured programming.
%
Nevertheless, the heap is essential to express resizable structures, such as
vectors and graphs, and also to move them to outer scopes.

To deal with the mismatch between life cycle of objects in the heap against the
lexical structure of programs, programming languages offer extra mechanisms to
manage the heap.
%
For instance, low-level languages, such as \emph{C} and \emph{Zig}, rely on
explicit deallocation primitives, while higher-level languages, such as
\emph{Python} and \emph{Java}, rely on automatic garbage collection to
deallocate memory.

More sophisticated type systems manage to reconcile heap deallocation with the
program structure.
%
\emph{Cyclone}~\cite{TODO} supports lexical regions that are attached to
blocks, and behave like local heaps.
Objects can be dynamically allocated into a region, which is deallocated as a
whole with all objects when its enclosing block terminates.
The type system of Cyclone ensures that no references can escape the scope of
regions to prevent dangling references.
%
\emph{Rust}~\cite{TODO} is based on the ownership semantics in which objects
in the heap can only have a unique owner reference, but multiple borrowed
references.
When the owner goes out of scope, the object in the heap is automatically
deallocated.
The type system of Rust also ensures that no borrowed references can escape the
owner scope.
%
These approaches enforce safety at compile time and have minimum runtime costs
(akin to explicit deallocation primitives).
Nevertheless, they impose significant restrictions on the expressiveness of the
languages.
For instance, objects in Cyclone can share ownership, but not move between
scopes, while objects in Rust can move between scopes, but not share ownership.

In this work, we explore
- dynamic language
- significant memory and runtime costs




stack deallocation)
However, even though these approaches are safe 


Patina: A Formalization of the Rust Programming Language
https://pling.jondgoodwin.com/post/cyclone/

- webserver, across multiple requests, stack ripping
    - even if fixed size, still requires the heap

- philosophy of structured programming
    - break vs exceptions
        - break linked to specific loop
            - cannot move across loop/func
        - exception linked to idea no catch
            - can move across catch/func
- problem with heap
    - references
    - escapes
- state of the art
    - move semantics
    - but no sharing
    - cyclone, rust
        - problem of callbacks
            - still holds for this work
- Ceu
    - restore reasoning
    - tuple, vector, dict
    - func, upval, noupval
    - loops, no break
    - throw/catch
    - defer
    - drop semantics
- Tradeoff
    - memory cost
    - runtime cost
    - still requires GC
    - single ref

 y second remark is that our intellectual powers are rather
geared to master static relations and that our powers to visualize
processes evolving in time are relatively poorly developed. For
that reason w e should do (as wise programmers aware of our
limitations) our utmost to shorten the conceptual gap between
the static program and the dynamic process, to m a k e the cor-
respondence between the program (spread out in text space) and
the process (spread out in time) as trivial as possible.

currently two alternatives:
    - malloc/free
    - GC
    - ownership semantics
        - move, borrow
            - implicit
        - Each value in Rust has an owner.
        - There can only be one owner at a time.
        - When the owner goes out of scope, the value will be dropped.

none enforced by the lexical structure



\label{sec.introduction}

\bibliographystyle{abbrv}
\bibliography{lexical}

\end{document}
