\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}

\usepackage{verbatim}
\usepackage{xspace}
\newcommand{\code}[1] {\texttt{\footnotesize{#1}}}
\newcommand{\lex} {\texttt{Dyn-Lex}\xspace}

\title {
    Dynamic Allocation with Runtime Lexical Memory Management
    % under Structured Programming
}

\author{Anonymous}
\address{Anonymous}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

%\begin{resumo} 
%\end{resumo}

\section{Introduction}
\label{sec.intro}

In structured programming, the control flow of programs is determined by the
hierarchical structure of the source code with sequences, conditionals, loops,
and subroutines.
%
In principle, programmers rely on the lexical nesting of such commands in
blocks to better organize and reason about the
program~\cite{dijk.goto,dijk.notes}.
%
Lexical blocks also determine the scope of variables, limiting their visibility
and lifetime, which helps to reason, not only about control flow, but also
about the memory organization of programs.

Regarding memory management, structured programming typically provides local
variables that use the stack to hold fixed-size data types, and references to
dynamically-allocated values (or objects) that use the heap to hold
variable-size data types.
%
The stack provides automatic memory management that is easy to reason, since it
deallocates memory in blocks that respect the lexical structure of the program.
%
However, the life cycle of objects have no correspondence with the lexical
structure, diverging from the basic principle of structured programming.
%
Nevertheless, the heap is essential to express resizable structures, such as
vectors and graphs, and is also a requirement to move objects between scopes.

To deal with the mismatch between the life cycle of objects against the lexical
structure of programs, programming languages offer extra mechanisms to manage
the heap.
%
For instance, lower-level languages, such as C and Zig, rely on explicit
allocation primitives, while higher-level languages, such as Python and Java,
rely on garbage collectors.

More sophisticated type systems can reconcile heap allocation with the program
structure.
%
In Cyclone~\cite{cyclone.regions}, lexical regions behave like local heaps that
are attached to blocks.
An object is explicitly allocated into a region, which is deallocated as a
whole with all containing objects when its enclosing block terminates.
%
In Rust~\cite{rust.book}, objects are owned by a unique lexical reference.
When the owner goes out of scope, the object is automatically deallocated.
%
The type systems of Cyclone and Rust ensure that no references can escape the
owning lexical scope, providing compile-time safety with minimum runtime
costs.
%
Nevertheless, they impose restrictions on the expressiveness of the languages.
For instance, objects in Cyclone can be shared freely, but cannot move between
scopes, while objects in Rust can safely move between scopes, but cannot share
ownership.

In this work, we explore the design of \lex, a dynamic language with runtime
lexical memory management for heap-allocated objects.
%
Objects in \lex have the following characteristics:
    (a) they are always attached to exactly one block;
    (b) they are automatically released from memory with their holding blocks;
    (c) they can be shared freely, except to outer scopes;
    (d) they can be explicitly moved to inner scopes, except if multi
        referenced.
    (e) they can be explicitly moved to outer scopes with no restrictions; and
%
Therefore, \lex can express arbitrary cyclic graphs with nodes residing at
different blocks, and move them between scopes when appropriate.
A garbage collector is still required to manage long-lasting blocks that create
too many objects.
%
However, like dynamic typing, all safety checks happen at runtime, which incur
in significant space and time overhead.
Nevertheless, our hypothesis is that like dynamic typing, it is reasonable to
pay these costs to improve expressiveness.

TODO: costs and results

In summary, as main contributions we evidence that
(a) lexically scoped objects help to reason about memory usage, that
(b) some allocation patterns cannot be statically inferred, and that
(c) the runtime overhead is not prohibitive, thus justifying the design of
    \lex.

The rest of the paper is organized as follows:
Section~\ref{sec.design} describes the design of \lex...
Section~\ref{sec.eval} evaluates our implementation...
Section~\ref{sec.related} discusses related work...
Section~\ref{sec.conclusion} concludes the paper.

\section{Design of \lex}
\label{sec.design}

\section{Performance Evaluation}
\label{sec.eval}

\section{Related Work}
\label{sec.related}

\section{Conclusion}
\label{sec.conclusion}

\begin{comment}
>>> string=32 | udata=56 | udata=40 | proto=128
>>> upval=40 | table=56 | closure=48

>>> tuple=56, vector=72, dict=64, clos=80

The type system of Cyclone ensures that no references can escape the scope of
regions to prevent dangling references.
Rust..., but multiple borrowed references.
The type system of Rust also ensures that no borrowed references can escape the
owner scope.
 (akin to explicit deallocation primitives).

In addition to standard structured mechanisms, \lex supports dynamic data
structures (tuples, vectors, and dictionaries), exceptions, deferred
expressions, and a limited form of closures.
%
costs mem
    - hold = (tp,block,nxt)
    - _var_
costs run
    - all assigns

Patina: A Formalization of the Rust Programming Language
https://pling.jondgoodwin.com/post/cyclone/

- webserver, across multiple requests, stack ripping
    - even if fixed size, still requires the heap

- problem with heap
    - references
    - escapes
- state of the art
    - move semantics
    - but no sharing
    - cyclone, rust
        - problem of callbacks
            - still holds for this work
- Ceu
    - restore reasoning
    - func, upval, noupval
    - drop semantics
- Tradeoff
    - memory cost
    - runtime cost
    - still requires GC
    - single ref

 y second remark is that our intellectual powers are rather
geared to master static relations and that our powers to visualize
processes evolving in time are relatively poorly developed. For
that reason w e should do (as wise programmers aware of our
limitations) our utmost to shorten the conceptual gap between
the static program and the dynamic process, to m a k e the cor-
respondence between the program (spread out in text space) and
the process (spread out in time) as trivial as possible.

currently two alternatives:
    - malloc/free
    - GC
    - ownership semantics
        - move, borrow
            - implicit
        - Each value in Rust has an owner.
        - There can only be one owner at a time.
        - When the owner goes out of scope, the value will be dropped.

none enforced by the lexical structure
\end{comment}

\bibliographystyle{abbrv}
\bibliography{lexical}

\end{document}
