\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}

\usepackage{verbatim}
\usepackage{xspace}
\newcommand{\code}[1] {\texttt{\footnotesize{#1}}}
\newcommand{\lex} {\code{dyn-lex}\xspace}

\title {
    Dynamic Allocation with Runtime Lexical Memory Management
    % under Structured Programming
}

\author{Anonymous}
\address{Anonymous}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

%\begin{resumo} 
%\end{resumo}

\section{Introduction}
\label{sec.intro}

The classical structured programming paradigm determines the control flow of
programs based on the lexical hierarchical structure of the source code.
%
In principle, programmers rely on the textual nesting of sequences,
conditionals, loops, and subroutines to break the source code into blocks to
better organize and reason about the program~\cite{TODO}.
%
Lexical blocks also determine the scope of variables, limiting their visibility
and lifetime, which helps to reason, not only about control flow, but also
about the memory organization of programs.

Regarding memory management, structured programming typically provides global
and local variables that use the static and stack memory regions to hold
fixed-size data types, and also provides references to dynamically-allocated
values (or objects) that use the heap to hold variable-size data types.
%
The static and stack regions provide automatic memory management that are easy
to reason, since they deallocate memory in blocks that respect the lexical
structure of the program.
%
However, the life cycle of objects have no correspondence with the program
structure, which diverges from the basic principle of structured programming.
%
Nevertheless, the heap is essential to express resizable structures, such as
vectors and graphs, and also to move them to outer scopes.

To deal with the mismatch between life cycle of objects against the lexical
structure of programs, programming languages offer extra mechanisms to manage
the heap.
%
For instance, low-level languages, such as C and Zig, rely on explicit
deallocation primitives, while higher-level languages, such as Python and Java,
rely on automatic garbage collection to deallocate memory.

More sophisticated type systems manage to reconcile heap deallocation with the
program structure.
%
Cyclone~\cite{TODO} supports lexical regions that are attached to blocks, and
behave like local heaps.
An object can be dynamically allocated into a region, which is deallocated as a
whole with all objects when its enclosing block terminates.
The type system of Cyclone ensures that no references can escape the scope of
regions to prevent dangling references.
%
Rust~\cite{TODO} is based on the ownership semantics in which objects can only
have a unique owner reference, but multiple borrowed references.
When the owner goes out of scope, the object in the heap is automatically
deallocated.
The type system of Rust also ensures that no borrowed references can escape the
owner scope.
%
These approaches enforce safety at compile time and have minimum runtime costs
(akin to explicit deallocation primitives).
Nevertheless, they impose significant restrictions on the expressiveness of the
languages.
For instance, objects in Cyclone can be shared freely, but cannot move between
scopes, while objects in Rust can safely move between scopes, but cannot share
ownership.

In this work, we explore the design of \lex a dynamic language with safe
lexical memory management for heap-allocated objects.
%
In addition to standard structured mechanisms, \lex supports dynamic data
structures (tuples, vectors, and dictionaries), exceptions, deferred
expressions, and a limited form of closures.
A garbage collector is still required to manage long-lasting blocks that create
too many objects.
%
Objects are subject to the following rules:
    (a) they are always attached to exactly one block at any given time;
    (c) they are automatically released from memory when their holding blocks
        terminate;
    (d) they can be shared freely in equal or deeper scopes;
    (e) they can be explicitly moved to outer scopes, but remain attached to a
        single block;
%
In \lex, it is possible to express arbitrary cyclic graphs with nodes residing
at different blocks, while also moving them between scopes.
%
However, like dynamic typing, all scope checks to enforce safety happen at
runtime, which incur in significant space and time overhead.
Nevertheless, our hypothesis is that like dynamic typing, it may be worth to
pay these costs to improve expressiveness.

TODO: costs and results

\begin{comment}
>>> string=32 | udata=56 | udata=40 | proto=128
>>> upval=40 | table=56 | closure=48

>>> tuple=56, vector=72, dict=64, clos=80

costs mem
    - hold = (tp,block,nxt)
    - _var_
costs run
    - all assigns

Patina: A Formalization of the Rust Programming Language
https://pling.jondgoodwin.com/post/cyclone/

- webserver, across multiple requests, stack ripping
    - even if fixed size, still requires the heap

- problem with heap
    - references
    - escapes
- state of the art
    - move semantics
    - but no sharing
    - cyclone, rust
        - problem of callbacks
            - still holds for this work
- Ceu
    - restore reasoning
    - func, upval, noupval
    - drop semantics
- Tradeoff
    - memory cost
    - runtime cost
    - still requires GC
    - single ref

 y second remark is that our intellectual powers are rather
geared to master static relations and that our powers to visualize
processes evolving in time are relatively poorly developed. For
that reason w e should do (as wise programmers aware of our
limitations) our utmost to shorten the conceptual gap between
the static program and the dynamic process, to m a k e the cor-
respondence between the program (spread out in text space) and
the process (spread out in time) as trivial as possible.

currently two alternatives:
    - malloc/free
    - GC
    - ownership semantics
        - move, borrow
            - implicit
        - Each value in Rust has an owner.
        - There can only be one owner at a time.
        - When the owner goes out of scope, the value will be dropped.

none enforced by the lexical structure
\end{comment}

\bibliographystyle{abbrv}
\bibliography{lexical}

\end{document}
